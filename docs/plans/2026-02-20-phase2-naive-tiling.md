# Phase 2: Naive Tiling Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Produce functional vector tiles from GeoParquet files that render correctly in MapLibre.

**Architecture:** Read GeoParquet → extract geometries via geozero → for each zoom/tile: clip to bounds, simplify, encode as MVT → write PMTiles (custom writer from spec). Single-threaded, in-memory. Compare output against tippecanoe golden files for verification.

**Tech Stack:** Rust, geozero (geometry extraction - simpler than geoarrow), geo (clipping/simplification), prost (MVT encoding), custom PMTiles v3 writer (from spec)

---

## Critical Fixes from Adversarial Review

1. **PMTiles Writer**: `pmtiles` crate is read-only. We implement our own writer from the PMTiles v3 spec.
2. **Geometry Extraction**: Use `geozero` instead of complex geoarrow accessor pattern.
3. **LineString Clipping**: Use correct `BooleanOps` signature - `polygon.clip()` not `linestring.clip()`.
4. **CI Workflow**: Use `dtolnay/rust-toolchain` not `rust-action`.
5. **geo-traits**: Add explicit dependency for `ToGeoGeometry` trait.

---

## Prerequisites

- Golden PMTiles in `tests/fixtures/golden/` (generated by tippecanoe) ✓
- Test GeoParquet files in `tests/fixtures/realdata/` ✓
- Existing tile coordinate math in `crates/core/src/tile.rs` ✓

---

## Task 1: PMTiles Writer - Header and Structures

**Difficulty:** 5/10 | **Time:** 45 min

**Files:**
- Create: `crates/core/src/pmtiles_writer.rs`
- Modify: `crates/core/src/lib.rs`
- Modify: `crates/core/Cargo.toml`

**Step 1: Add dependencies**

In `crates/core/Cargo.toml`, add:

```toml
[dependencies]
# ... existing ...
flate2 = "1"  # For gzip compression
```

**Step 2: Write PMTiles v3 header structures with tests**

Create `crates/core/src/pmtiles_writer.rs`:

```rust
//! PMTiles v3 writer implementation.
//!
//! Implements the PMTiles v3 spec: https://github.com/protomaps/PMTiles/blob/main/spec/v3/spec.md

use std::io::{Write, Seek, SeekFrom};
use crate::{Error, Result};

/// PMTiles v3 magic number
const PMTILES_MAGIC: &[u8; 7] = b"PMTiles";
const PMTILES_VERSION: u8 = 3;

/// Tile type enumeration
#[derive(Debug, Clone, Copy, PartialEq)]
#[repr(u8)]
pub enum TileType {
    Unknown = 0,
    Mvt = 1,
    Png = 2,
    Jpeg = 3,
    Webp = 4,
    Avif = 5,
}

/// Compression type enumeration
#[derive(Debug, Clone, Copy, PartialEq)]
#[repr(u8)]
pub enum Compression {
    Unknown = 0,
    None = 1,
    Gzip = 2,
    Brotli = 3,
    Zstd = 4,
}

/// PMTiles v3 header (127 bytes)
#[derive(Debug, Clone)]
pub struct Header {
    pub root_dir_offset: u64,
    pub root_dir_length: u64,
    pub json_metadata_offset: u64,
    pub json_metadata_length: u64,
    pub leaf_dirs_offset: u64,
    pub leaf_dirs_length: u64,
    pub tile_data_offset: u64,
    pub tile_data_length: u64,
    pub addressed_tiles_count: u64,
    pub tile_entries_count: u64,
    pub tile_contents_count: u64,
    pub clustered: bool,
    pub internal_compression: Compression,
    pub tile_compression: Compression,
    pub tile_type: TileType,
    pub min_zoom: u8,
    pub max_zoom: u8,
    pub min_lon: f32,
    pub min_lat: f32,
    pub max_lon: f32,
    pub max_lat: f32,
    pub center_zoom: u8,
    pub center_lon: f32,
    pub center_lat: f32,
}

impl Default for Header {
    fn default() -> Self {
        Self {
            root_dir_offset: 127,
            root_dir_length: 0,
            json_metadata_offset: 0,
            json_metadata_length: 0,
            leaf_dirs_offset: 0,
            leaf_dirs_length: 0,
            tile_data_offset: 0,
            tile_data_length: 0,
            addressed_tiles_count: 0,
            tile_entries_count: 0,
            tile_contents_count: 0,
            clustered: true,
            internal_compression: Compression::Gzip,
            tile_compression: Compression::Gzip,
            tile_type: TileType::Mvt,
            min_zoom: 0,
            max_zoom: 14,
            min_lon: -180.0,
            min_lat: -85.0,
            max_lon: 180.0,
            max_lat: 85.0,
            center_zoom: 0,
            center_lon: 0.0,
            center_lat: 0.0,
        }
    }
}

impl Header {
    /// Serialize header to 127 bytes
    pub fn to_bytes(&self) -> [u8; 127] {
        let mut buf = [0u8; 127];

        // Magic (7 bytes)
        buf[0..7].copy_from_slice(PMTILES_MAGIC);

        // Version (1 byte)
        buf[7] = PMTILES_VERSION;

        // Offsets and lengths (8 bytes each, little-endian)
        buf[8..16].copy_from_slice(&self.root_dir_offset.to_le_bytes());
        buf[16..24].copy_from_slice(&self.root_dir_length.to_le_bytes());
        buf[24..32].copy_from_slice(&self.json_metadata_offset.to_le_bytes());
        buf[32..40].copy_from_slice(&self.json_metadata_length.to_le_bytes());
        buf[40..48].copy_from_slice(&self.leaf_dirs_offset.to_le_bytes());
        buf[48..56].copy_from_slice(&self.leaf_dirs_length.to_le_bytes());
        buf[56..64].copy_from_slice(&self.tile_data_offset.to_le_bytes());
        buf[64..72].copy_from_slice(&self.tile_data_length.to_le_bytes());

        // Tile counts
        buf[72..80].copy_from_slice(&self.addressed_tiles_count.to_le_bytes());
        buf[80..88].copy_from_slice(&self.tile_entries_count.to_le_bytes());
        buf[88..96].copy_from_slice(&self.tile_contents_count.to_le_bytes());

        // Clustered flag
        buf[96] = if self.clustered { 1 } else { 0 };

        // Compression and type
        buf[97] = self.internal_compression as u8;
        buf[98] = self.tile_compression as u8;
        buf[99] = self.tile_type as u8;

        // Zoom levels
        buf[100] = self.min_zoom;
        buf[101] = self.max_zoom;

        // Bounds (f32, 4 bytes each)
        buf[102..106].copy_from_slice(&self.min_lon.to_le_bytes());
        buf[106..110].copy_from_slice(&self.min_lat.to_le_bytes());
        buf[110..114].copy_from_slice(&self.max_lon.to_le_bytes());
        buf[114..118].copy_from_slice(&self.max_lat.to_le_bytes());

        // Center
        buf[118] = self.center_zoom;
        buf[119..123].copy_from_slice(&self.center_lon.to_le_bytes());
        buf[123..127].copy_from_slice(&self.center_lat.to_le_bytes());

        buf
    }
}

/// Convert tile coordinates to a TileID for PMTiles
/// Uses Hilbert curve ordering for spatial locality
pub fn tile_id(z: u8, x: u32, y: u32) -> u64 {
    if z == 0 {
        return 0;
    }

    let base_id: u64 = (1..z as u64).map(|i| 4u64.pow(i as u32)).sum();
    let tile_in_level = xy_to_hilbert(z, x, y);
    base_id + tile_in_level + 1
}

/// Convert x,y to Hilbert curve index at zoom level z
fn xy_to_hilbert(z: u8, x: u32, y: u32) -> u64 {
    let n = 1u32 << z;
    let mut rx: u32;
    let mut ry: u32;
    let mut s: u32;
    let mut d: u64 = 0;
    let mut x = x;
    let mut y = y;

    s = n / 2;
    while s > 0 {
        rx = if (x & s) > 0 { 1 } else { 0 };
        ry = if (y & s) > 0 { 1 } else { 0 };
        d += (s as u64) * (s as u64) * ((3 * rx) ^ ry) as u64;

        // Rotate
        if ry == 0 {
            if rx == 1 {
                x = s - 1 - x;
                y = s - 1 - y;
            }
            std::mem::swap(&mut x, &mut y);
        }
        s /= 2;
    }
    d
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_header_size() {
        let header = Header::default();
        let bytes = header.to_bytes();
        assert_eq!(bytes.len(), 127);
    }

    #[test]
    fn test_header_magic() {
        let header = Header::default();
        let bytes = header.to_bytes();
        assert_eq!(&bytes[0..7], b"PMTiles");
        assert_eq!(bytes[7], 3); // Version
    }

    #[test]
    fn test_tile_id_zoom_0() {
        assert_eq!(tile_id(0, 0, 0), 0);
    }

    #[test]
    fn test_tile_id_zoom_1() {
        // At zoom 1, there are 4 tiles (0,0), (1,0), (0,1), (1,1)
        // Base ID for z=1 is 1
        let id_0_0 = tile_id(1, 0, 0);
        let id_1_0 = tile_id(1, 1, 0);
        let id_0_1 = tile_id(1, 0, 1);
        let id_1_1 = tile_id(1, 1, 1);

        // All should be unique and in range [1, 5)
        let ids = vec![id_0_0, id_1_0, id_0_1, id_1_1];
        assert!(ids.iter().all(|&id| id >= 1 && id < 5));

        // All unique
        let mut sorted = ids.clone();
        sorted.sort();
        sorted.dedup();
        assert_eq!(sorted.len(), 4);
    }
}
```

**Step 3: Add module to lib.rs**

```rust
pub mod pmtiles_writer;
```

**Step 4: Run tests**

Run: `cargo test --package gpq-tiles-core pmtiles_writer -- --nocapture`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/core/src/pmtiles_writer.rs crates/core/src/lib.rs crates/core/Cargo.toml
git commit -m "feat: add PMTiles v3 header and tile ID calculation"
```

---

## Task 2: PMTiles Writer - Directory Encoding

**Difficulty:** 6/10 | **Time:** 45 min

**Files:**
- Modify: `crates/core/src/pmtiles_writer.rs`

**Step 1: Add varint encoding and directory entry structures**

Add to `crates/core/src/pmtiles_writer.rs`:

```rust
/// A directory entry pointing to tile data
#[derive(Debug, Clone)]
pub struct DirEntry {
    pub tile_id: u64,
    pub offset: u64,
    pub length: u32,
    pub run_length: u32, // Number of consecutive tiles with same data
}

/// Encode a u64 as a varint (protobuf-style)
pub fn encode_varint(mut value: u64, buf: &mut Vec<u8>) {
    while value >= 0x80 {
        buf.push((value as u8) | 0x80);
        value >>= 7;
    }
    buf.push(value as u8);
}

/// Encode directory entries with delta encoding
pub fn encode_directory(entries: &[DirEntry]) -> Vec<u8> {
    let mut buf = Vec::new();

    // Number of entries
    encode_varint(entries.len() as u64, &mut buf);

    // Delta-encoded tile IDs
    let mut last_id = 0u64;
    for entry in entries {
        encode_varint(entry.tile_id - last_id, &mut buf);
        last_id = entry.tile_id;
    }

    // Run lengths
    for entry in entries {
        encode_varint(entry.run_length as u64, &mut buf);
    }

    // Lengths
    for entry in entries {
        encode_varint(entry.length as u64, &mut buf);
    }

    // Delta-encoded offsets
    let mut last_offset = 0u64;
    for entry in entries {
        let offset = if entry.run_length > 0 { entry.offset } else { 0 };
        encode_varint(offset.wrapping_sub(last_offset), &mut buf);
        last_offset = offset + entry.length as u64;
    }

    buf
}

/// Compress data with gzip
pub fn gzip_compress(data: &[u8]) -> std::io::Result<Vec<u8>> {
    use flate2::write::GzEncoder;
    use flate2::Compression;
    use std::io::Write;

    let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
    encoder.write_all(data)?;
    encoder.finish()
}

#[cfg(test)]
mod tests {
    // ... existing tests ...

    #[test]
    fn test_encode_varint_small() {
        let mut buf = Vec::new();
        encode_varint(127, &mut buf);
        assert_eq!(buf, vec![127]);
    }

    #[test]
    fn test_encode_varint_large() {
        let mut buf = Vec::new();
        encode_varint(128, &mut buf);
        assert_eq!(buf, vec![0x80, 0x01]);
    }

    #[test]
    fn test_encode_varint_larger() {
        let mut buf = Vec::new();
        encode_varint(300, &mut buf);
        assert_eq!(buf, vec![0xAC, 0x02]); // 300 = 0x12C
    }

    #[test]
    fn test_encode_directory_empty() {
        let entries: Vec<DirEntry> = vec![];
        let encoded = encode_directory(&entries);
        assert_eq!(encoded, vec![0]); // Just the count (0)
    }

    #[test]
    fn test_encode_directory_single() {
        let entries = vec![DirEntry {
            tile_id: 1,
            offset: 0,
            length: 100,
            run_length: 1,
        }];
        let encoded = encode_directory(&entries);
        assert!(!encoded.is_empty());
        assert_eq!(encoded[0], 1); // Count = 1
    }
}
```

**Step 2: Run tests**

Run: `cargo test --package gpq-tiles-core pmtiles_writer -- --nocapture`
Expected: PASS

**Step 3: Commit**

```bash
git add crates/core/src/pmtiles_writer.rs
git commit -m "feat: add PMTiles directory encoding with varints"
```

---

## Task 3: PMTiles Writer - Full Writer

**Difficulty:** 6/10 | **Time:** 60 min

**Files:**
- Modify: `crates/core/src/pmtiles_writer.rs`

**Step 1: Implement the full PMTiles writer**

Add to `crates/core/src/pmtiles_writer.rs`:

```rust
use std::fs::File;
use std::io::{BufWriter, Write, Seek, SeekFrom};
use std::path::Path;
use std::collections::BTreeMap;

use crate::tile::TileBounds;

/// Tile data to be written
pub struct TileData {
    pub z: u8,
    pub x: u32,
    pub y: u32,
    pub data: Vec<u8>,
}

/// PMTiles writer
pub struct PmtilesWriter {
    tiles: BTreeMap<u64, Vec<u8>>, // tile_id -> compressed data
    min_zoom: u8,
    max_zoom: u8,
    bounds: TileBounds,
}

impl PmtilesWriter {
    pub fn new() -> Self {
        Self {
            tiles: BTreeMap::new(),
            min_zoom: 255,
            max_zoom: 0,
            bounds: TileBounds::empty(),
        }
    }

    /// Add a tile (will be gzip compressed)
    pub fn add_tile(&mut self, z: u8, x: u32, y: u32, data: &[u8]) -> std::io::Result<()> {
        let compressed = gzip_compress(data)?;
        let id = tile_id(z, x, y);
        self.tiles.insert(id, compressed);

        self.min_zoom = self.min_zoom.min(z);
        self.max_zoom = self.max_zoom.max(z);

        Ok(())
    }

    /// Set geographic bounds
    pub fn set_bounds(&mut self, bounds: &TileBounds) {
        self.bounds = *bounds;
    }

    /// Write the PMTiles file
    pub fn write_to_file(&self, path: &Path) -> crate::Result<()> {
        let file = File::create(path)
            .map_err(|e| crate::Error::PMTilesWrite(format!("Failed to create file: {}", e)))?;
        let mut writer = BufWriter::new(file);

        // Collect tile data and build directory
        let mut tile_data_buf = Vec::new();
        let mut entries = Vec::new();

        for (&id, data) in &self.tiles {
            entries.push(DirEntry {
                tile_id: id,
                offset: tile_data_buf.len() as u64,
                length: data.len() as u32,
                run_length: 1,
            });
            tile_data_buf.extend_from_slice(data);
        }

        // Encode and compress directory
        let dir_bytes = encode_directory(&entries);
        let compressed_dir = gzip_compress(&dir_bytes)
            .map_err(|e| crate::Error::PMTilesWrite(format!("Failed to compress directory: {}", e)))?;

        // Calculate offsets
        let root_dir_offset = 127u64;
        let root_dir_length = compressed_dir.len() as u64;
        let metadata_offset = root_dir_offset + root_dir_length;
        let metadata = b"{}"; // Minimal JSON metadata
        let compressed_metadata = gzip_compress(metadata)
            .map_err(|e| crate::Error::PMTilesWrite(format!("Failed to compress metadata: {}", e)))?;
        let metadata_length = compressed_metadata.len() as u64;
        let tile_data_offset = metadata_offset + metadata_length;
        let tile_data_length = tile_data_buf.len() as u64;

        // Build header
        let mut header = Header::default();
        header.root_dir_offset = root_dir_offset;
        header.root_dir_length = root_dir_length;
        header.json_metadata_offset = metadata_offset;
        header.json_metadata_length = metadata_length;
        header.leaf_dirs_offset = 0;
        header.leaf_dirs_length = 0;
        header.tile_data_offset = tile_data_offset;
        header.tile_data_length = tile_data_length;
        header.addressed_tiles_count = self.tiles.len() as u64;
        header.tile_entries_count = entries.len() as u64;
        header.tile_contents_count = self.tiles.len() as u64;
        header.min_zoom = self.min_zoom;
        header.max_zoom = self.max_zoom;
        header.min_lon = self.bounds.lng_min as f32;
        header.min_lat = self.bounds.lat_min as f32;
        header.max_lon = self.bounds.lng_max as f32;
        header.max_lat = self.bounds.lat_max as f32;
        header.center_lon = ((self.bounds.lng_min + self.bounds.lng_max) / 2.0) as f32;
        header.center_lat = ((self.bounds.lat_min + self.bounds.lat_max) / 2.0) as f32;
        header.center_zoom = (self.min_zoom + self.max_zoom) / 2;

        // Write everything
        writer.write_all(&header.to_bytes())
            .map_err(|e| crate::Error::PMTilesWrite(format!("Failed to write header: {}", e)))?;
        writer.write_all(&compressed_dir)
            .map_err(|e| crate::Error::PMTilesWrite(format!("Failed to write directory: {}", e)))?;
        writer.write_all(&compressed_metadata)
            .map_err(|e| crate::Error::PMTilesWrite(format!("Failed to write metadata: {}", e)))?;
        writer.write_all(&tile_data_buf)
            .map_err(|e| crate::Error::PMTilesWrite(format!("Failed to write tile data: {}", e)))?;

        writer.flush()
            .map_err(|e| crate::Error::PMTilesWrite(format!("Failed to flush: {}", e)))?;

        Ok(())
    }
}

impl Default for PmtilesWriter {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    // ... existing tests ...

    #[test]
    fn test_writer_creates_file() {
        let mut writer = PmtilesWriter::new();

        // Add a minimal tile
        let mvt_data = vec![0x1a, 0x00]; // Minimal valid MVT
        writer.add_tile(0, 0, 0, &mvt_data).unwrap();
        writer.set_bounds(&TileBounds::new(-180.0, -85.0, 180.0, 85.0));

        let path = Path::new("/tmp/test-pmtiles-writer.pmtiles");
        let _ = fs::remove_file(path);

        writer.write_to_file(path).expect("Should write file");

        assert!(path.exists(), "File should exist");

        // Check file starts with PMTiles magic
        let data = fs::read(path).unwrap();
        assert_eq!(&data[0..7], b"PMTiles");
        assert_eq!(data[7], 3); // Version 3

        let _ = fs::remove_file(path);
    }
}
```

**Step 2: Run tests**

Run: `cargo test --package gpq-tiles-core pmtiles_writer -- --nocapture`
Expected: PASS

**Step 3: Commit**

```bash
git add crates/core/src/pmtiles_writer.rs
git commit -m "feat: implement full PMTiles v3 writer"
```

---

## Task 4: Geometry Extraction with Geozero

**Difficulty:** 5/10 | **Time:** 45 min

**Files:**
- Create: `crates/core/src/geometry.rs`
- Modify: `crates/core/src/lib.rs`

**Step 1: Write failing test**

Create `crates/core/src/geometry.rs`:

```rust
//! Geometry extraction from GeoParquet files using geozero.

use std::path::Path;
use geo::Geometry;
use crate::{Error, Result};
use crate::tile::TileBounds;

/// Extract geometries from a GeoParquet file
pub fn extract_geometries(_path: &Path) -> Result<Vec<(Geometry<f64>, usize)>> {
    todo!("Implement geometry extraction")
}

/// Calculate bounding box of all geometries
pub fn calculate_bbox(_path: &Path) -> Result<TileBounds> {
    todo!("Implement bbox calculation")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_geometries_returns_geometries() {
        let fixture = Path::new("../../tests/fixtures/realdata/open-buildings.parquet");
        if !fixture.exists() {
            eprintln!("Skipping: fixture not found");
            return;
        }

        let geometries = extract_geometries(fixture).expect("Should extract");
        assert!(!geometries.is_empty(), "Should have geometries");
        assert!(geometries.len() > 100, "Should have many features");
    }

    #[test]
    fn test_calculate_bbox_returns_valid_bounds() {
        let fixture = Path::new("../../tests/fixtures/realdata/open-buildings.parquet");
        if !fixture.exists() {
            eprintln!("Skipping: fixture not found");
            return;
        }

        let bbox = calculate_bbox(fixture).expect("Should calculate bbox");

        // Andorra bounds: ~1.4-1.8 lon, ~42.4-42.7 lat
        assert!(bbox.lng_min > 1.0 && bbox.lng_min < 2.0);
        assert!(bbox.lng_max > 1.0 && bbox.lng_max < 2.0);
        assert!(bbox.lat_min > 42.0 && bbox.lat_min < 43.0);
        assert!(bbox.lat_max > 42.0 && bbox.lat_max < 43.0);
        assert!(bbox.lng_min > -180.0, "Should not be world bounds");
    }
}
```

**Step 2: Add module to lib.rs**

```rust
pub mod geometry;
```

**Step 3: Run test to verify it fails**

Run: `cargo test --package gpq-tiles-core geometry -- --nocapture`
Expected: FAIL with "not yet implemented"

**Step 4: Commit failing test**

```bash
git add crates/core/src/geometry.rs crates/core/src/lib.rs
git commit -m "test: add failing geometry extraction tests (TDD red)"
```

---

## Task 5: Geometry Extraction - Implementation

**Difficulty:** 5/10 | **Time:** 45 min

**Files:**
- Modify: `crates/core/src/geometry.rs`

**Step 1: Implement using geozero**

Replace content of `crates/core/src/geometry.rs`:

```rust
//! Geometry extraction from GeoParquet files using geozero.

use std::path::Path;
use geo::{Geometry, BoundingRect};
use geozero::ToGeo;
use parquet::arrow::arrow_reader::ParquetRecordBatchReaderBuilder;
use arrow_array::cast::AsArray;
use arrow_array::types::GenericBinaryType;

use crate::{Error, Result};
use crate::tile::TileBounds;

/// Extract geometries from a GeoParquet file
pub fn extract_geometries(path: &Path) -> Result<Vec<(Geometry<f64>, usize)>> {
    let file = std::fs::File::open(path)
        .map_err(|e| Error::GeoParquetRead(format!("Failed to open: {}", e)))?;

    let builder = ParquetRecordBatchReaderBuilder::try_new(file)
        .map_err(|e| Error::GeoParquetRead(format!("Failed to create reader: {}", e)))?;

    let reader = builder.build()
        .map_err(|e| Error::GeoParquetRead(format!("Failed to build reader: {}", e)))?;

    let mut geometries = Vec::new();
    let mut row_offset = 0;

    for batch_result in reader {
        let batch = batch_result
            .map_err(|e| Error::GeoParquetRead(format!("Failed to read batch: {}", e)))?;

        // Find geometry column (usually WKB binary)
        let geom_idx = batch.schema().fields().iter()
            .position(|f| f.name() == "geometry" || f.name().contains("geom"))
            .ok_or_else(|| Error::GeoParquetRead("No geometry column".to_string()))?;

        let geom_col = batch.column(geom_idx);

        // Try as binary array (WKB)
        if let Some(binary_array) = geom_col.as_binary_opt::<i32>() {
            for i in 0..binary_array.len() {
                if binary_array.is_null(i) {
                    continue;
                }
                let wkb = binary_array.value(i);
                if let Ok(geom) = geozero::wkb::Wkb(wkb.to_vec()).to_geo() {
                    geometries.push((geom, row_offset + i));
                }
            }
        } else if let Some(binary_array) = geom_col.as_binary_opt::<i64>() {
            for i in 0..binary_array.len() {
                if binary_array.is_null(i) {
                    continue;
                }
                let wkb = binary_array.value(i);
                if let Ok(geom) = geozero::wkb::Wkb(wkb.to_vec()).to_geo() {
                    geometries.push((geom, row_offset + i));
                }
            }
        } else {
            return Err(Error::GeoParquetRead("Unsupported geometry format".to_string()));
        }

        row_offset += batch.num_rows();
    }

    Ok(geometries)
}

/// Calculate bounding box of all geometries
pub fn calculate_bbox(path: &Path) -> Result<TileBounds> {
    let geometries = extract_geometries(path)?;

    if geometries.is_empty() {
        return Err(Error::GeoParquetRead("No geometries found".to_string()));
    }

    let mut bounds = TileBounds::empty();

    for (geom, _) in &geometries {
        if let Some(rect) = geom.bounding_rect() {
            bounds.expand(&TileBounds::new(
                rect.min().x,
                rect.min().y,
                rect.max().x,
                rect.max().y,
            ));
        }
    }

    if !bounds.is_valid() {
        return Err(Error::GeoParquetRead("Invalid bounds".to_string()));
    }

    Ok(bounds)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_geometries_returns_geometries() {
        let fixture = Path::new("../../tests/fixtures/realdata/open-buildings.parquet");
        if !fixture.exists() {
            eprintln!("Skipping: fixture not found");
            return;
        }

        let geometries = extract_geometries(fixture).expect("Should extract");
        assert!(!geometries.is_empty(), "Should have geometries");
        assert!(geometries.len() > 100, "Should have many features");
    }

    #[test]
    fn test_calculate_bbox_returns_valid_bounds() {
        let fixture = Path::new("../../tests/fixtures/realdata/open-buildings.parquet");
        if !fixture.exists() {
            eprintln!("Skipping: fixture not found");
            return;
        }

        let bbox = calculate_bbox(fixture).expect("Should calculate bbox");

        assert!(bbox.lng_min > 1.0 && bbox.lng_min < 2.0);
        assert!(bbox.lng_max > 1.0 && bbox.lng_max < 2.0);
        assert!(bbox.lat_min > 42.0 && bbox.lat_min < 43.0);
        assert!(bbox.lat_max > 42.0 && bbox.lat_max < 43.0);
        assert!(bbox.lng_min > -180.0, "Should not be world bounds");
    }
}
```

**Step 2: Run tests**

Run: `cargo test --package gpq-tiles-core geometry -- --nocapture`
Expected: PASS

**Step 3: Commit**

```bash
git add crates/core/src/geometry.rs
git commit -m "feat: implement geometry extraction with geozero (TDD green)"
```

---

## Task 6: Geometry Clipping

**Difficulty:** 5/10 | **Time:** 45 min

**Files:**
- Create: `crates/core/src/clip.rs`
- Modify: `crates/core/src/lib.rs`

**Step 1: Implement clipping with correct BooleanOps usage**

Create `crates/core/src/clip.rs`:

```rust
//! Geometry clipping to tile bounds.

use geo::{Geometry, Point, LineString, Polygon, MultiPolygon, MultiLineString, Coord, Rect};
use geo::algorithm::bool_ops::BooleanOps;
use geo::algorithm::bounding_rect::BoundingRect;
use crate::tile::TileBounds;

/// Clip a geometry to tile bounds
pub fn clip_geometry(geom: &Geometry<f64>, bounds: &TileBounds, buffer: f64) -> Option<Geometry<f64>> {
    let buffered = TileBounds::new(
        bounds.lng_min - buffer,
        bounds.lat_min - buffer,
        bounds.lng_max + buffer,
        bounds.lat_max + buffer,
    );

    match geom {
        Geometry::Point(p) => clip_point(p, &buffered).map(Geometry::Point),
        Geometry::LineString(ls) => clip_linestring(ls, &buffered),
        Geometry::Polygon(poly) => clip_polygon(poly, &buffered).map(Geometry::Polygon),
        Geometry::MultiPolygon(mp) => clip_multipolygon(mp, &buffered).map(Geometry::MultiPolygon),
        Geometry::MultiLineString(mls) => clip_multilinestring(mls, &buffered),
        other => {
            if let Some(rect) = other.bounding_rect() {
                if intersects_bounds(&rect, &buffered) {
                    return Some(other.clone());
                }
            }
            None
        }
    }
}

fn intersects_bounds(rect: &Rect<f64>, bounds: &TileBounds) -> bool {
    rect.max().x >= bounds.lng_min
        && rect.min().x <= bounds.lng_max
        && rect.max().y >= bounds.lat_min
        && rect.min().y <= bounds.lat_max
}

fn clip_point(point: &Point<f64>, bounds: &TileBounds) -> Option<Point<f64>> {
    if point.x() >= bounds.lng_min
        && point.x() <= bounds.lng_max
        && point.y() >= bounds.lat_min
        && point.y() <= bounds.lat_max
    {
        Some(*point)
    } else {
        None
    }
}

fn clip_linestring(ls: &LineString<f64>, bounds: &TileBounds) -> Option<Geometry<f64>> {
    let clip_rect = Rect::new(
        Coord { x: bounds.lng_min, y: bounds.lat_min },
        Coord { x: bounds.lng_max, y: bounds.lat_max },
    );
    let clip_poly = clip_rect.to_polygon();

    // Correct usage: polygon.clip(&multilinestring, invert)
    let mls = MultiLineString::new(vec![ls.clone()]);
    let clipped = clip_poly.clip(&mls, false);

    if clipped.0.is_empty() {
        None
    } else if clipped.0.len() == 1 {
        Some(Geometry::LineString(clipped.0.into_iter().next().unwrap()))
    } else {
        Some(Geometry::MultiLineString(clipped))
    }
}

fn clip_multilinestring(mls: &MultiLineString<f64>, bounds: &TileBounds) -> Option<Geometry<f64>> {
    let clip_rect = Rect::new(
        Coord { x: bounds.lng_min, y: bounds.lat_min },
        Coord { x: bounds.lng_max, y: bounds.lat_max },
    );
    let clip_poly = clip_rect.to_polygon();
    let clipped = clip_poly.clip(mls, false);

    if clipped.0.is_empty() {
        None
    } else {
        Some(Geometry::MultiLineString(clipped))
    }
}

fn clip_polygon(poly: &Polygon<f64>, bounds: &TileBounds) -> Option<Polygon<f64>> {
    let clip_rect = Rect::new(
        Coord { x: bounds.lng_min, y: bounds.lat_min },
        Coord { x: bounds.lng_max, y: bounds.lat_max },
    );
    let clip_poly = clip_rect.to_polygon();
    let clipped = poly.intersection(&clip_poly);

    if clipped.0.is_empty() {
        None
    } else {
        Some(clipped.0.into_iter().next().unwrap())
    }
}

fn clip_multipolygon(mp: &MultiPolygon<f64>, bounds: &TileBounds) -> Option<MultiPolygon<f64>> {
    let clip_rect = Rect::new(
        Coord { x: bounds.lng_min, y: bounds.lat_min },
        Coord { x: bounds.lng_max, y: bounds.lat_max },
    );
    let clip_poly = clip_rect.to_polygon();
    let clipped = mp.intersection(&clip_poly);

    if clipped.0.is_empty() {
        None
    } else {
        Some(clipped)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use geo::point;

    #[test]
    fn test_clip_point_inside() {
        let bounds = TileBounds::new(0.0, 0.0, 10.0, 10.0);
        let point = point!(x: 5.0, y: 5.0);
        assert!(clip_point(&point, &bounds).is_some());
    }

    #[test]
    fn test_clip_point_outside() {
        let bounds = TileBounds::new(0.0, 0.0, 10.0, 10.0);
        let point = point!(x: 15.0, y: 5.0);
        assert!(clip_point(&point, &bounds).is_none());
    }

    #[test]
    fn test_clip_polygon_partial() {
        let bounds = TileBounds::new(0.0, 0.0, 10.0, 10.0);
        let poly = Polygon::new(
            LineString::from(vec![
                Coord { x: -5.0, y: -5.0 },
                Coord { x: 5.0, y: -5.0 },
                Coord { x: 5.0, y: 5.0 },
                Coord { x: -5.0, y: 5.0 },
                Coord { x: -5.0, y: -5.0 },
            ]),
            vec![],
        );

        let result = clip_polygon(&poly, &bounds);
        assert!(result.is_some());

        let clipped = result.unwrap();
        for coord in clipped.exterior().coords() {
            assert!(coord.x >= 0.0 && coord.x <= 10.0);
            assert!(coord.y >= 0.0 && coord.y <= 10.0);
        }
    }

    #[test]
    fn test_clip_polygon_outside() {
        let bounds = TileBounds::new(0.0, 0.0, 10.0, 10.0);
        let poly = Polygon::new(
            LineString::from(vec![
                Coord { x: 20.0, y: 20.0 },
                Coord { x: 30.0, y: 20.0 },
                Coord { x: 30.0, y: 30.0 },
                Coord { x: 20.0, y: 30.0 },
                Coord { x: 20.0, y: 20.0 },
            ]),
            vec![],
        );
        assert!(clip_polygon(&poly, &bounds).is_none());
    }
}
```

**Step 2: Add module**

```rust
pub mod clip;
```

**Step 3: Run tests**

Run: `cargo test --package gpq-tiles-core clip -- --nocapture`
Expected: PASS

**Step 4: Commit**

```bash
git add crates/core/src/clip.rs crates/core/src/lib.rs
git commit -m "feat: implement geometry clipping with correct BooleanOps"
```

---

## Task 7: Simplification

**Difficulty:** 3/10 | **Time:** 20 min

**Files:**
- Create: `crates/core/src/simplify.rs`
- Modify: `crates/core/src/lib.rs`

**Step 1: Implement simplification**

Create `crates/core/src/simplify.rs`:

```rust
//! Zoom-based geometry simplification.

use geo::{Geometry, Simplify};

/// Simplify geometry for zoom level
pub fn simplify_for_zoom(geom: &Geometry<f64>, zoom: u8, extent: u32) -> Geometry<f64> {
    let tile_degrees = 360.0 / (1u64 << zoom) as f64;
    let pixel_degrees = tile_degrees / extent as f64;
    let tolerance = pixel_degrees * 2.0;

    if tolerance < 1e-10 {
        return geom.clone();
    }

    match geom {
        Geometry::Point(_) | Geometry::MultiPoint(_) => geom.clone(),
        Geometry::LineString(ls) => Geometry::LineString(ls.simplify(&tolerance)),
        Geometry::Polygon(poly) => Geometry::Polygon(poly.simplify(&tolerance)),
        Geometry::MultiPolygon(mp) => Geometry::MultiPolygon(mp.simplify(&tolerance)),
        Geometry::MultiLineString(mls) => Geometry::MultiLineString(mls.simplify(&tolerance)),
        other => other.clone(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use geo::{LineString, Coord};

    #[test]
    fn test_simplify_reduces_vertices() {
        let coords: Vec<Coord<f64>> = (0..100)
            .map(|i| Coord { x: i as f64 * 0.01, y: (i as f64 * 0.1).sin() * 0.001 })
            .collect();
        let line = LineString::new(coords);
        let geom = Geometry::LineString(line.clone());

        let simplified = simplify_for_zoom(&geom, 0, 4096);
        if let Geometry::LineString(s) = simplified {
            assert!(s.coords().count() < line.coords().count());
        }
    }

    #[test]
    fn test_points_unchanged() {
        let point = Geometry::Point(geo::point!(x: 1.0, y: 2.0));
        assert_eq!(point, simplify_for_zoom(&point, 5, 4096));
    }
}
```

**Step 2: Add module, run tests, commit**

```bash
# Add to lib.rs: pub mod simplify;
cargo test --package gpq-tiles-core simplify -- --nocapture
git add crates/core/src/simplify.rs crates/core/src/lib.rs
git commit -m "feat: implement zoom-based simplification"
```

---

## Task 8: MVT Encoding

**Difficulty:** 5/10 | **Time:** 45 min

**Files:**
- Create: `crates/core/src/mvt.rs`
- Modify: `crates/core/src/lib.rs`

**Step 1: Implement MVT encoding (zigzag, delta, commands)**

Create `crates/core/src/mvt.rs`:

```rust
//! MVT encoding utilities.

use geo::{Coord, LineString, Polygon};
use crate::tile::TileBounds;

pub fn zigzag_encode(n: i32) -> u32 {
    ((n << 1) ^ (n >> 31)) as u32
}

pub fn zigzag_decode(n: u32) -> i32 {
    ((n >> 1) as i32) ^ (-((n & 1) as i32))
}

pub fn geo_to_tile_coords(coord: Coord<f64>, bounds: &TileBounds, extent: u32) -> (i32, i32) {
    let x = ((coord.x - bounds.lng_min) / bounds.width() * extent as f64).round() as i32;
    let y = ((bounds.lat_max - coord.y) / bounds.height() * extent as f64).round() as i32;
    (x, y)
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Command { MoveTo, LineTo, ClosePath }

impl Command {
    fn id(self) -> u32 {
        match self { Command::MoveTo => 1, Command::LineTo => 2, Command::ClosePath => 7 }
    }
}

pub fn encode_command(cmd: Command, count: u32) -> u32 {
    (cmd.id() & 0x7) | (count << 3)
}

pub fn decode_command(cmd_int: u32) -> (Command, u32) {
    let id = cmd_int & 0x7;
    let count = cmd_int >> 3;
    let cmd = match id { 1 => Command::MoveTo, 2 => Command::LineTo, 7 => Command::ClosePath, _ => panic!("Unknown") };
    (cmd, count)
}

pub fn encode_polygon(poly: &Polygon<f64>, bounds: &TileBounds, extent: u32) -> Vec<u32> {
    let mut cmds = Vec::new();
    encode_ring(&mut cmds, poly.exterior(), bounds, extent);
    for interior in poly.interiors() {
        encode_ring(&mut cmds, interior, bounds, extent);
    }
    cmds
}

pub fn encode_linestring(ls: &LineString<f64>, bounds: &TileBounds, extent: u32) -> Vec<u32> {
    let mut cmds = Vec::new();
    if ls.coords().count() < 2 { return cmds; }

    let coords: Vec<_> = ls.coords().map(|c| geo_to_tile_coords(*c, bounds, extent)).collect();

    cmds.push(encode_command(Command::MoveTo, 1));
    cmds.push(zigzag_encode(coords[0].0));
    cmds.push(zigzag_encode(coords[0].1));

    if coords.len() > 1 {
        cmds.push(encode_command(Command::LineTo, (coords.len() - 1) as u32));
        let (mut px, mut py) = coords[0];
        for &(x, y) in &coords[1..] {
            cmds.push(zigzag_encode(x - px));
            cmds.push(zigzag_encode(y - py));
            px = x; py = y;
        }
    }
    cmds
}

fn encode_ring(cmds: &mut Vec<u32>, ring: &LineString<f64>, bounds: &TileBounds, extent: u32) {
    if ring.coords().count() < 4 { return; }

    let coords: Vec<_> = ring.coords().take(ring.coords().count() - 1)
        .map(|c| geo_to_tile_coords(*c, bounds, extent)).collect();

    if coords.is_empty() { return; }

    cmds.push(encode_command(Command::MoveTo, 1));
    cmds.push(zigzag_encode(coords[0].0));
    cmds.push(zigzag_encode(coords[0].1));

    if coords.len() > 1 {
        cmds.push(encode_command(Command::LineTo, (coords.len() - 1) as u32));
        let (mut px, mut py) = coords[0];
        for &(x, y) in &coords[1..] {
            cmds.push(zigzag_encode(x - px));
            cmds.push(zigzag_encode(y - py));
            px = x; py = y;
        }
    }
    cmds.push(encode_command(Command::ClosePath, 1));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_zigzag() {
        assert_eq!(zigzag_encode(0), 0);
        assert_eq!(zigzag_encode(-1), 1);
        assert_eq!(zigzag_encode(1), 2);
        for i in -1000..1000 { assert_eq!(zigzag_decode(zigzag_encode(i)), i); }
    }

    #[test]
    fn test_commands() {
        assert_eq!(encode_command(Command::MoveTo, 1), 9);
        assert_eq!(decode_command(9), (Command::MoveTo, 1));
    }
}
```

**Step 2: Add module, run tests, commit**

```bash
cargo test --package gpq-tiles-core mvt -- --nocapture
git add crates/core/src/mvt.rs crates/core/src/lib.rs
git commit -m "feat: implement MVT encoding"
```

---

## Task 9: Tile Generation Pipeline

**Difficulty:** 5/10 | **Time:** 45 min

**Files:**
- Create: `crates/core/src/tiler.rs`
- Modify: `crates/core/src/lib.rs`

**Step 1: Implement tile generation**

Create `crates/core/src/tiler.rs` with the pipeline that ties geometry → clip → simplify → encode.

*(Code similar to original plan but using correct modules)*

**Step 2: Run tests, commit**

---

## Task 10: Integration and Golden Tests

**Difficulty:** 4/10 | **Time:** 30 min

**Files:**
- Create: `crates/core/tests/golden_comparison.rs`
- Modify: `crates/core/src/lib.rs` (wire up Converter)

**Step 1: Wire up Converter, create integration test**

**Step 2: Run against golden files**

---

## Task 11: CI Configuration

**Difficulty:** 2/10 | **Time:** 15 min

**Files:**
- Create: `.github/workflows/test.yml`

Use `dtolnay/rust-toolchain` (not `rust-action`).

---

## Summary Table

| Task | Description | Difficulty | Time Est. |
|------|-------------|------------|-----------|
| 1 | PMTiles Writer - Header | 5/10 | 45 min |
| 2 | PMTiles Writer - Directory | 6/10 | 45 min |
| 3 | PMTiles Writer - Full | 6/10 | 60 min |
| 4 | Geometry Extraction - Test | 3/10 | 15 min |
| 5 | Geometry Extraction - Impl | 5/10 | 45 min |
| 6 | Clipping | 5/10 | 45 min |
| 7 | Simplification | 3/10 | 20 min |
| 8 | MVT Encoding | 5/10 | 45 min |
| 9 | Tile Pipeline | 5/10 | 45 min |
| 10 | Integration Tests | 4/10 | 30 min |
| 11 | CI Configuration | 2/10 | 15 min |

**Total: ~7 hours estimated**

**Average Difficulty: 4.5/10**

---

## Key Changes from Original Plan

1. **Tasks 1-3 (NEW)**: PMTiles v3 writer from scratch instead of using non-existent `pmtiles` write API
2. **Task 5**: Use `geozero` for WKB parsing instead of complex geoarrow accessor pattern
3. **Task 6**: Fixed `BooleanOps::clip()` signature - polygon clips linestring, not vice versa
4. **Task 11**: Fixed CI action name: `dtolnay/rust-toolchain`

Each task is TDD: write failing test → implement → verify → commit.
